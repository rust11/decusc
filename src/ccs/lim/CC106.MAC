;???;	CC106 - unfinished attempt to update Decus-C
CANSI=0
;ADV155:	CALL	GETNAM		;GATHER UP THE NAME
;	CALL	LOOKUP		;SYMBOL TABLE
;6$:	MOV	LSTRUC,CSTRUC	;SET CURRENT STRUCTURE TO LAST SEEN	;u1-
;7$:	INC	MOSFLG		;SET THE MOSFLAG
;8$:	BIS	INMOSF,MOSFLG	;SET MOSFLAG CORRECTLY AND
.iif	ndf	rsx	rsx	=	1	;assume rsx	;01+
	.title	cc106
	.ident	/x01.05/
 
	.nlist	bex, cnd
	.enabl	lc, gbl
	.list	meb						;01-
 
;
; c compiler.
; code editor
;
; version x01
;
; ian hammond		11-dec-03
;
; edit history
; 01 11-dec-03 ih	create source module
 
.if ne	rsx							;01
	.mcall	call
	.mcall	callr
	.mcall	return
.iff
.macro	call	arg1,arg2
.if b	arg2
	  jsr	pc,arg1
.iff
	  jsr	arg1,arg2
.endc
.endm	call

.macro	callr	arg1
	  jmp	arg1
.endm

.macro	return	arg1
.if b	arg1
	  rts	pc
.iff
	  rts	arg1
.endc
.endm	return
.endc								;01
.macro	psh 	arg
	mov	arg,-(sp)
.endm
.macro	pop	arg
	mov	(sp)+,arg
.endm
.sbttl	data
.GLOBL	DECSYN
.enabl	mcl
.mcall	.print,.ttyout

decsyn:	.print	#10$
	.exit
10$:	.asciz	/oops/
	.even

C$ANSI::.word	1		;compile ansi 
	edlen. = 512.
	ed.lin = 161.

e$dtst::.word	0

e$dctx:	.blkw	50.

e$daut:	.word	0		;autos active
e$dact:	.word	0		;active flag
e$dipt:	.word	e$dbuf		;input pointer
e$dopt:	.word	e$dbuf		;output pointer
e$dbas:	.word	e$dbuf		;
e$dlen:	.word	edlen.		;
e$dlim:	.word	e$dbuf+edlen.	;end of buffer
e$dbuf:	.blkb	512.		;edit buffer

.sbttl	ed$aut - flag autos in progress

ed$aut::call	ed$chk
	call	ed$ini
	inc	e$daut
	return

.sbttl	ed$sta - start regurgitating

ed$sta::call	ed$chk			;
	cmp	e$dipt,e$dopt
	beq	10$
	clr	e$daut			;not in autos no more
	call	ed$sav			;save lexical state
	inc	e$dact			;we're active
10$:	return

ed$chk:	tstb	cflag			;enabled?
	bne	10$			;yep
.if eq cansi
	tst	(sp)+			;nope - skip routine
.endc
10$:	return


ed$ini:	psh	r0			;
	mov	e$dbas,r0		;
	mov	r0,e$dipt		;
	mov	r0,e$dopt		;
	add	e$dlen,r0		;get buffer size
	sub	#2,r0			;adjust for 3-byte entries
	mov	r0,e$dlim		;
	pop	r0
	return

;	ED$SAV saves LEX1/VAL1
;	ED$RES restores to LEX0/VAL0 because it's called
;	via GETC *after* SCAN has moved LEX1/VAL1 to LEX0/VAL0.
;	SCAN checks for various things when sliding howeve
;	none of those things can occur in our context.

	.enabl	lsb
ed$res:	psh	r2
	psh	r1
	psh	r0
;	CLR	CLASS		;SET THINGS UNDEFINED
;	CLR	TYPE		;
;	CLR	DIMP		;
;	CLR	DOPE		;
;	CLR	LONGF		;'LONG' FLAG
;	CLR	SHORTF		;'SHORT' FLAG
;	CLR	USIGNF		;'UNSIGNED' FLAG

	mov	#e$dctx,r0
	mov	#lex1,r1
	br	10$
ed$sav:	call	5$
	mov	#op.sem,lex1
	return

5$:	psh	r2
	psh	r1
	psh	r0
	mov	#lex1,r0
	mov	#e$dctx,r1
10$:	mov	#5,r2
20$:	mov	(r0)+,(r1)+
	dec	r2
	bne	20$
	pop	r0
	pop	r1
	pop	r2
	return
	.dsabl	lsb
.sbttl	ed$asg - store assignment

; ???	Catch error flush mode
;
;	 in:	int a = 1, b = 2;
;		char c, d='z';
;
;	 out:	int a, b;
;		char c,d;
;
;		a = 1;
;		b = 2;
;		d = 'z'
;
;	No support for structure initializers.
;
;	o We get control at the assignment operator.
;	o R5 points to the symbol
;	o LEX1 has the operator
;	o Exit if operator isn't OP.ASG
;	o Store the symbol name
;	o Store the assignment expression
;	o Return with LEX1 OP.CMA or OP.SEM as found

ed$asg::call	ed$chk		;make sure we're enabled
	tst	e$daut		;doing an auto?
	beq	30$		;nope
	cmp	lex1,#op.asg	;assignment coming?
	bne	30$		;nope
				;
	psh	r1		;
	psh	r0		;
;	mov	#ed.lin,r0	;
;	call	ed$put		;store line number
	mov	r5,r0		;get the symbol
	add	#s.name,r0	;point to the name
	call	ed$pst		;store string
	movb	#'=,r0		;name=
	call	ed$put
	call	getc
	cmpb	r0,#32.		;a space?
	bne	11$		;nope
10$:	call	getc		;name=...
11$:	cmpb	r0,#op.eof	;end of file?
	beq	40$		;forget it
	mov	#op.cma,lex1	;
	cmpb	r0,#',		;(need to balance () etc)
	beq	20$		;
	mov	#op.sem,lex1	;
	cmpb	r0,#';		;
	beq	20$		;
	call	ed$put		;
	br	10$		;
20$:
.if ne 0
.ttyout #'{
mov ip,r1
psh #6
21$:.ttyout (r1)+
dec (sp)
bne 21$
.ttyout #'}
tst(sp)+
.endc
	mov	#';,r0		;
	call	ed$put		;
cmp	lex1,#op.sem	;
bne	25$
;inc e$dtst

25$:	pop	r0		;
	pop	r1		;
30$:	return
40$:	call	decsyn
.sbttl	ed$pst - put string

ed$pst:	psh	r1			;
	mov	r0,r1			;
10$:	movb	(r1)+,r0		;
	beq	20$			;
	call	ed$put
	br	10$
20$:	pop	r1
	return

.sbttl	ed$put - put character or line number

ed$put:	psh	r1			;
	mov	e$dopt,r1		;
	cmp	r1,e$dlim		;out of luck?
	bhis	30$			;yes
	movb	r0,(r1)+		;store
	cmpb	r0,#ed.lin		;store line number?
	bne	10$			;nope
	movb	lineno,(r1)+		;
	movb	lineno+1,(r1)+		;
br 15$
10$:
;.ttyout
15$:	mov	r1,e$dopt		;
	pop	r1			;
20$:	return
30$:
;bpt
	call	decsyn

.sbttl	ed$get - get character

ed$adv::tst	e$dact			;active?
	beq	10$			;nope
br 10$
	cmp	e$dipt,e$dopt		;just finished it?
	bne	10$			;nope
	clr	e$dact			;not active
	call	ed$ini			;init
	call	ed$res			;restore
;bpt
	tst	(pc)+			;
10$:	sec
	return

ed$ugt::tst	e$dact			;us or them?
	beq	10$
	dec	e$dipt			;
	tst	(pc)+			;
10$:	sec
	return

ed$get::tst	e$dact			;active?
	beq	30$			;nope
	psh	r1			;
	mov	e$dipt,r1		;
	cmp	r1,e$dopt		;done enough?
	bhis	20$			;yes
	cmpb	(r1),#ed.lin		;new line?
	bne	10$			;nope
	inc	r1			;
	movb	(r1)+,lineno		;yep
	movb	(r1)+,lineno+1		;
10$:	movb	(r1)+,r0		;get the character
	mov	r1,e$dipt		;update pointer
cmp r1,e$dopt
bne 13$
;bpt
13$:
	pop	r1			;
;psh r0
;.ttyout #'[
;.ttyout (sp)
;.ttyout #']
;pop r0
;bpt
	clc
	return
20$:;bpt
	clr	e$dact			;not active
	call	ed$ini			;init
	call	ed$res			;restore
	pop	r1
30$:	sec
	return
.sbttl	ed$dec - check declaration coming

ed$dec::psh	r1
	psh	r0
	CLR	CLASS		;SET THINGS UNDEFINED
	CLR	TYPE		;
	CLR	DIMP		;
	CLR	DOPE		;
	CLR	LONGF		;'LONG' FLAG
	CLR	SHORTF		;'SHORT' FLAG
	CLR	USIGNF		;'UNSIGNED' FLAG

	MOV	LEX1,R0		;GET PEEK TOKEN
	MOV	#30$,R1		;LOOK IT UP IN THE TABLE
10$:	cmp	r1,#40$		;all done
	bhis	20$		;yep
	CMP	R0,(R1)+	;
	bne	10$		;
;	CMP	R0,#OP.ID	;an identifier
;	bne	25$		;nope
;	MOV	VAL1,R1		;SYMBOL POINTER.
;	cmpB	S.CLAS(R1),CL.TYP ;TYPEDEF?
20$:	TST	(PC)+
25$:	SEC
	pop	r0
	pop	r1
	RETURN

;
; TRANSFER TABLE.
;

30$:	.WORD	OP.AUT
	.WORD	OP.STA
	.WORD	OP.EXT
	.WORD	OP.REG
	.WORD	OP.TYP
	.WORD	OP.INT
	.WORD	OP.VOI
	.WORD	OP.CHR
	.WORD	OP.FLT
	.WORD	OP.DBL
	.WORD	OP.LNG
	.WORD	OP.SHO
	.WORD	OP.UNS
	.WORD	OP.STR
	.WORD	OP.UNI
;	.WORD	OP.ID
40$:				;END OF THE TABLE

.end
