.IIF	NDF	RSX	RSX	=	1	;Assume RSX	;01+
	.TITLE	CC105
	.ident	/X01.05/
 
	.NLIST	BEX, CND
	.ENABL	LC, GBL
	.LIST	MEB						;01-
 
;
; C COMPILER.
; I/O CODE.
;
; VERSION X01
;
; DAVID G. CONROY	04-JAN-78
;
; Edit history
; 01 31-Jul-79 MM	Added RT11 support
; 02 25-Feb-81 MM	Dump source to int file as a comment if "list trees"
; 03 21-Jun-82 MM	Allow 8-bit ascii for national letters.
; 04 29-Nov-82 MM	Larger input lines.
; 05 18-Mar-85 MM	Changed CCABR1 to ERROR1
 
	.GLOBL	CODST1
	.GLOBL	CODNL1
	.GLOBL	CODC1
	.GLOBL	CODNM1
	.GLOBL	GETC
	.GLOBL	UNGETC
	.GLOBL	DOECHO
 
.IF NE	RSX							;01
	.MCALL	CALL
	.MCALL	CALLR
	.MCALL	RETURN
.IFF
.MACRO	CALL	ARG1,ARG2
.IF B	ARG2
	  JSR	PC,ARG1
.IFF
	  JSR	ARG1,ARG2
.ENDC
.ENDM	CALL

.MACRO	CALLR	ARG1
	  JMP	ARG1
.ENDM

.MACRO	RETURN	ARG1
.IF B	ARG1
	  RTS	PC
.IFF
	  RTS	ARG1
.ENDC
.ENDM	RETURN
.ENDC								;01

;
; Define buffer sizes.  SIZ.IB must match up with the preprocessor output.
; This is set large to compensate for macro expansion increases.
; SIZ.OB is set small to prevent pass 2 from getting any bigger.
; Only comments (-L for "write source to .S file") will write anything
; beyond 128. bytes.
;
; SIZ.IB is referenced here and in CC001
; SIZ.OB is referenced here and in CC200
;
.IIF	NDF	SIZ.IB	SIZ.IB = 300.				;04
.IIF	NDF	SIZ.OB	SIZ.OB = 80.				;04
 
;
; EQUIVALENCES
;
 
NL	=	12		;ASCII NL
BLANK	=	40		;ASCII BLANK
 
;
; LOCAL DATA.
;
	.PSECT	LD105,GBL,OVR					;01
OP:	.WORD	OB		;OUTPUT POINTER
IP:	.BLKW	1		;INPUT POINTER
IC:	.WORD	0		;INPUT COUNT
ILEN:	.WORD	0		;INPUT RECORD LENGTH
IB:	.BLKB	SIZ.IB		;INPUT BUFFER			;04
OB:	.BLKB	SIZ.OB		;OUTPUT BUFFER			;04

;
; MESSAGES.
;
	.PSECT	ER105						;01
ERR01:	.ASCIZ	"I/O error on intermediate (.TM1) file"		;01
ERR03:	.ASCIZ	"I/O error on expanded source (.TMP) file"	;01

	.EVEN
	.PSECT	CC105						;01
CC105::								;01
;+
; ** GETC   - GET CHARACTER FROM SOURCE FILE
; ** UNGETC - PUT CHARACTER BACK
;
; OUTPUTS: (GETC)
;	R0=CHAR
;	C BIT SET ON EOF
;-
;DEBUG+
;IN...:	.ASCII	/Input  :/
;	.BYTE	200
;	.EVEN
;DEBUG-

 
UNGETC:	DEC	IP		;UNGET JUST BACKS UP THE POINTER
	INC	IC		;AND FIXES THE COUNT
	RETURN			;
 
GETC:	DEC	IC		;ANYTHING
	BPL	10$		;YES
	MOV	#SIZ.IB-1,-(SP)	;SAVE LENGTH			;01 +;04
	MOV	#IB,-(SP)	;AND BUFFER LOCATION
	MOV	#P1IN,R0	;R0 -> FILE BLOCK
	CALL	RDLINE		;GO GET THE LINE
	BIT	(SP)+,(SP)+	;EMPTY THE STACK
	BCS	20$		;ERROR
	MOV	R0,ILEN		;SAVE LINE LENGTH FOR ECHO
;DEBUG+
;	.MCALL	.PRINT
;	MOV	R0,-(SP)
;	CLRB	IB(R0)
;	.PRINT	#IN...
;	.PRINT	#IB
;	MOV	(SP)+,R0
;DEBUG-
;
; ERASE TRAILING BLANKS (FOR -L ECHO)				;02+
5$:	BEQ	7$		;EXIT IF EMPTY LINE
	CMPB	#BLANK,IB-1(R0)	;BLANK?
	BNE	7$		;NO, EXIT
	DEC	R0		;YES, DROP COUNTER
	BR	5$		;AND TRY AGAIN
7$:				;				;02-
	MOVB	#NL,IB(R0)	;PUT A NEWLINE ON THE END	;01 -
	MOV	#IB,IP		;WIND BACK POINTER
	MOV	R0,IC		;RESET COUNT
;
; IF LFLAG (LIST TREES) IS SET, DUMP NON-BLANK LINES TO THE	;02+
; INTERMEDIATE FILE FOR EVENTUAL INCLUSION IN THE .S FILE
;
	BEQ	10$		;DON'T DUMP BLANK LINES.
	TSTB	LFLAG		;LISTING TREES?
	BEQ	10$		;IF NOT, DON'T BOTHER
	CLRB	IB+1(R0)	;NULL-TRAIL THE TEXT
	MOV	#'@,R0		;OUTPUT AN '@' DIRECTIVE
	CALL	CODC1		;
	MOV	#IB,R0		;NOW, THE <NEWLINE> TRAILED
	CALL	CODST1		;SOURCE LINE			;02-
 
10$:	MOVB	@IP,R0		;PICK UP CHARACTER
;;	BIC	#177600,R0	;(7 BIT ASCII)			;03
	INC	IP		;UPDATE BUFFER POINTER
	CLC			;GOOD RETURN
	RETURN			;

20$:	TST	R0		;IS THE ERROR EOF		;01
	BEQ	30$		;YES
	MOV	#ERR03,R0	;DIE
;	CALL	ERROR1		;WITH A MESSAGE			;01/05
	JMP	FATAL1		;				;01/05

30$:	SEC			;C BIT SET ON EOF
	RETURN			;
 
;+
; ** DOECHO - ECHO SOURCE LINE (FOR -V)
;
; THIS ROUTINE IS CALLED TO ECHO THE CURRENT SOURCE RECORD ONTO THE
; ERROR STREAM.
;
; USES:
;	R0
;-
 
DOECHO:
	MOV	R1,-(SP)	;SAVE A REGISTER		;01 +
	MOV	#IB,R0		;R0 -> LINE START
	MOV	ILEN,R1		;R1 := LINE LENGTH
	ADD	R0,R1		;R1 -> LINE END
	CLRB	(R1)		;FORCE END OF LINE
	CALL	CCERR		;CALL COMMON ERROR WRITER
	MOVB	#NL,(R1)	;FORCE NL TRAILER AGAIN
	MOV	(SP)+,R1	;RECOVER R1			;01 -
	RETURN			;

;+
; ** CODC1 - PUT OUT A CHARACTER (PASS 1)
;
; OUTPUT 1 CHARACTER TO THE INTERMEDIATE FILE. THE CHARACTERS ARE BUF-
; FERED UNTIL NEWLINE, WHEN THE ACTUAL WRITE IS DONE.
;
; INPUTS:
;	R0=CHARACTER
;
; USES:
;	R0
;-
 
CODC1:	CMPB	R0,#NL		;NEWLINE?
	BEQ	10$		;YES
	MOVB	R0,@OP		;NO, JUST STORE IN THE BUFFER
	CMP	OP,#OB+SIZ.OB-1	;IS THERE ROOM?	 (FOR COMMENTS)	;04
	BHIS	20$		;IF NOT, JUST RETURN		;04
	INC	OP		;UPDATE THE POINTER
	BR	20$		;AND RETURN
 
10$:	SUB	#OB,OP		;COMPUTE RECORD SIZE
	MOV	OP,-(SP)	;SAVE LENGTH			;01 +
	MOV	#OB,-(SP)	;AND BUFFER START
	MOV	#P1OUT,R0	;R0 -> FDB
	CALL	PUTTXT		;DO IT
	BIT	(SP)+,(SP)+	;EMPTY THE STACK		;01 -
	BCS	30$		;ERROR
	MOV	#OB,OP		;BACK UP POINTER
20$:	RETURN			;DONE
 
30$:	MOV	#ERR01,R0	;ABORT
;	CALL	ERROR1		;				;01/05
	JMP	FATAL1		;				;01/05
 
;+
; ** CODST1 - PUT OUT A STRING (PASS 1)
;
; THIS ROUTINE PUTS OUT AN ASCIZ STRING TO THE CODE FILE USING MANY
; CALLS TO CODC1.
;
; INPUTS:
;	R0=POINTER TO STRING
;
; USES:
;	R0
;-
 
CODST1:	MOV	R1,-(SP)	;GET WORKING COPY OF POINTER
	MOV	R0,R1		;
 
10$:	MOVB	(R1)+,R0	;GET CHARACTER
	BEQ	20$		;BR IF NULL
	CALL	CODC1		;PUT IT OUT
	BR	10$		;
 
20$:	MOV	(SP)+,R1	;RETURN
	RETURN			;
 
;+
; ** CODNL1 - PUT OUT A NEWLINE
;
; USES:
;	NO REGISTERS
;-
 
CODNL1:	MOV	R0,-(SP)	;SAVE
	MOVB	#NL,R0		;PUT OUT NEWLINE VIA CODC1
	CALL	CODC1		;
	MOV	(SP)+,R0	;RETURN
	RETURN			;
 
;+
; ** CODNM1 - PUT OUT AN OCTAL NUMBER
;
; THE NUMBER IS CONVERTED INTO OCTAL ASCII WITH SUPRESSED LEADING
; ZEROS AND IS WRITTEN TO THE OUTPUT FILE VIA CODC1.
;
; INPUTS:
;	R0=THE NUMBER
;-
 
CODNM1:	MOV	R0,-(SP)	;GET SOME REGISTERS
	MOV	R1,-(SP)	;
	MOV	R2,-(SP)	;
 
	MOV	#4,R2		;DIGIT COUNT
	MOV	R0,R1		;COPY THE NUMBER
	ASL	R1		;TOP DIGIT
	BCC	20$		;ZERO, SUPRESS
	MOVB	#'1,R0		;PUT OUT THE '1'
	CALL	CODC1		;
	BR	30$		;AND KILL SUPRESSION
 
20$:	MOV	#6,R0		;MAX 4 DIGITS, WITH SUPRESSION
	ASL	R1		;MAKE DIGIT
	ROL	R0		;
	ASL	R1		;
	ROL	R0		;
	ASL	R1		;
	ROL	R0		;
	CMPB	R0,#'0		;IF A '0', DON'T PRINT
	BNE	40$		;
	DEC	R2		;
	BNE	20$		;
 
30$:	MOV	#6,R0		;PUT OUT THE REST
	ASL	R1		;MAKE DIGIT
	ROL	R0		;
	ASL	R1		;
	ROL	R0		;
	ASL	R1		;
	ROL	R0		;
40$:	CALL	CODC1		;OUTPUT
	DEC	R2		;LOOP TIL DONE
	BGE	30$		;
 
	MOV	(SP)+,R2	;RETURN
	MOV	(SP)+,R1	;
	MOV	(SP)+,R0	;
	RETURN			;
 
	.END
