
From:	RHEA::DECWRL::"decvax!minow"   18-SEP-1984 15:00  
To:	decwrl!rhea!rex!minow

Received: from DECWRL by DEC-RHEA with SMTP; Tue, 18 Sep 84 11:37-PDT
Received: by decwrl.ARPA (4.22.01/4.7.34)
	id AA24201; Tue, 18 Sep 84 11:37:00 pdt
Received: by decvax.UUCP (4.12/1.0)
	id AA24021; Tue, 18 Sep 84 13:07:16 edt
Date: Tue, 18 Sep 84 13:07:16 edt
Return-Path: <decvax!minow>
Message-Id: <8409181707.AA24021@decvax.UUCP>

From seismo!cmcl2!hipl!tony Mon Sep 17 22:06:55 1984
Received: by decvax.UUCP (4.12/1.0)
	id AA06843; Mon, 17 Sep 84 22:06:19 edt
Received: from cmcl2.UUCP by seismo.ARPA with UUCP; Mon, 17 Sep 84 18:46:40 EDT
Received: by NYU-CMCL2.ARPA; Mon, 17 Sep 84 18:10:50 edt
Received: by hipl.UUCP (4.12/4.7)
	id AA04101; Mon, 17 Sep 84 16:44:20 edt
Date: Mon, 17 Sep 84 16:44:20 edt
From: seismo!cmcl2!hipl!tony (Tony Movshon)
Message-Id: <8409172044.AA04101@hipl.UUCP>
To: minow@decvax
Status: R

----------------- Cut here and unpack with archx ----------------------
-h- decusc.fix	Mon Sep 17 15:45:23 1984	decusc.fix
To:	Martin Minow
From:	Tony Movshon

Re:	A set of bug-fixes for Decus C

Thanks for your prompt reply. Following are the changes for the amendments I
have made to TSX-Plus that affect the basic system (other changes to the
supplied utility programs are less important). To summarize briefly:

a. I added a flag variable to indicate operation under TSX-Plus ($$tsxp).
This required changes to SUPORT.MAC and INIT.MAC. I have included the entire
SUPORT.MAC plus changed sections to INIT.MAC as INIT.FIX. The only new code
is in INIT.MAC.

b. I fixed a bug in FWILD.MAC that caused the RT11 version to fail to find a
wildcarded file if it was the first entry in a directory segment. The changes
are in FWILD.FIX.

c. I changed the module SCREEN.MAC to recognize some terminals other than
plain-vanilla VT52s and VT100s, and also to use TSX-Plus' terminal type if
running under that operating system. The changes are in SCREEN.FIX.

These fixes have been tested under RT11 V5 and TSX-Plus V4.1 and V5.0. They
have not been checked under RT11 emulated under RSTS, but I can see no reason
why there should be any problems.

For your information, I can be reached by non-digital methods as:

	Prof. J. Anthony Movshon
	Department of Psychology
	New York University
	6 Washington Place, 8th floor
	New York, NY 10003
	Phone: 212 598-2818

You mentioned some other changes to Decus C subsequent to the submission I
received; would it be possible for you to send them (by machine or by mail)
to me so that I can include them in an RT11-specific submission for DECUS?
If by US Mail, I can use RX01 or RX02 format diskettes or 800 or 1600 bpi
magtape in RT11 format.

Thanks in advance, etc.

-h- suport.mac	Mon Sep 17 15:45:23 1984	suport.mac
; The only change here is the addition of a slot for the global variable
; "$$tsxp". I include the whole file because it's short and because the
; documentation changes as well as the code.
;
	.title	$$main	Start of C programs
	.ident	/000012/
;
;+
;
; Index		C main program
; Index		C library global variables
; Index		Operating-system unique variables
; Index		$$opsy -- Operating system id.
; Index		$$rsts -- Test if RSTS/E
; Index		$$tsxp -- Test if TSX-Plus
; Index		$$vms -- Test if VMS emulation
; Index		$$pos -- Test if P/OS (Professional)
; Index		$$uic -- RSX-11M default UIC
; Index		$$stnd -- Stack end point
; Index		$$scca -- RT-11 Ctrl/C flag
; Index		$$task -- RSX-11M task name
; Index		$$tick -- Clock interrupt rate
;
; Usage
;
;	$$main::		/* Start of C programs	*/
;
;	extern int   $$opsy;	/* Operating system	*/
;	extern int   $$rsts;	/* Non-zero if RSTS/E	*/
;	extern int   $$tsxp;	/* Non-zero if TSX-Plus	*/
;	extern int   $$vms;	/* Non-zero if VMS	*/
;	extern int   $$pos;	/* Non-zero if P/OS	*/
;	extern int   $$uic;	/* RSX: Default uic	*/
;	extern int   $$stnd;	/* Stack end point	*/
;	extern int   $$scca;	/* RT11: .scca control	*/
;	extern char  $$task[];	/* RSX: task name	*/
;	extern int   $$tick;	/* Clock interrupt rate	*/
;
; Internal
;
;	extern int   (*$$pptr)();  /* Profile printer	*/
;	extern int   $$argc;	/* Argument count	*/
;	extern int   *$$argv[];	/* Argument list ptr.	*/
;	extern char  *$$mtop;	/* Free memory start	*/
;	extern char  *$$mend;	/* Free memory end	*/
;
; Description
;
;	This module contains the run-time startoff for C programs.
;	It intializes the C environment and calls the main() subroutine.
;	On return from the main program, exit() is called to close
;	all files and return to the operating system.
;
;	The following globals are defined in this module:
;
;		$$opsy	Operating  system  unique  value.   This
;			value  is  7 on RT11, and set as per the
;			GTSK$ directive	on RSX-based systems:
;				RSX11-D		0.
;				RSX11-M		1.
;				RSX11-S		2.
;				IAS		3.
;				RSTS/E V7	4.
;				VMS		5.
;				RSX11-M+	6.
;				RT11		7.
;				P/OS		9.
;
;		$$rsts	This value is non-zero if the program is
;			running  on  RSTS/E.   It is zero if the
;			program  is  running  native  RSX, RT11,
;			P/OS or VMS compatibility mode.
;
;		$$tsxp	This value is non-zero if the program is
;			running on  TSX-Plus.  It is zero other-
;			wise.
;
;		$$vms	This value is non-zero if the program is
;			running  (in  compatibility mode) on Vax
;			VMS. It is zero otherwise.
;
;		$$pos	This value is non-zero if the program is
;			running on the Professional P/OS.  It is
;			zero otherwise.
;
;		$$stnd	The (top) end of the stack on entrance.
;
;		$$scca	On RT11, the .scca control  word.   This
;			is  needed  to  allow RSTS/E programs to
;			trap end of file.
;
;		$$task	On RSX, the task name in Ascii.
;
;		$$tick	The clock interrupt rate.  This  is  set
;			at  initialization  on  RT11  and on the
;			first call to time() or ftime() on RSX.
;
;		$$uic	On RSX, the default UIC word from GTSK$.
;
; Internal
;
;	All $$ values are for internal communication among runtime
;	library routines.  I.e., let them alone.
;
; Diagnostics
;
;	On RSX, the task aborts with a BPT if the standard error file
;	did not open.  Otherwise, explanatory error messages are printed.
;
; Bugs
;
;-
;
; Run time startoff.
;
; Edit history:
; 000001 22-May-80 MM	Redone from scratch
; 000002 26-Jun-80 MM	Added wild card slot in erriov
; 000003 27-Jun-80 MM	Moved file stuff to iov.mac
; 000004 21-Jul-80 MM	Added $$tick
; 000005 29-Jul-80 MM	Added $$mtop, $$mfree
; 000006 10-Dec-80 MM	Added $$vms
; 000007 01-Mar-82 MM	$$tick on both systems now
; 000008 22-Jun-82 MM	No environment (for now)
; 000009 02-Jul-82 MM	Newer library
; 000010 19-Jul-82 MM	Added $$pos
; 000011 22-Nov-82 JSL	Added support for initializers (based on original
;			implementation on 2-Aug-82)
; 000012 09-Jun-84 JAM	Added $$tsxp

.iif	ndf	rsx	rsx	=	1
;
; NOTE:  This module may not depend on the value of C$$EIS
;
; $$main is the entrance to C programs.  CSV$ refers to this
; global to pull support.obj from the RSX library.  As main programs
; cannot be loaded from a library on RT11, suport.obj must
; be named explicitly on all RT11 link commands.
;
 

.if ne	rsx
;
; RSX-specific equivalences
;
MAXMCR	=	80.		;MCR command line size -- same as $$init
.endc

	.globl	$$init							;11
;
; Global data.
; The '$' symbols are for internal use.
; The '.' symbols are set by the loader.
;
	.psect	c$data
$$pptr::
	.word	.+2		;Ptr to profile printer
	return			;Just hop back
$$opsy::
	.word	7		;Gets op sys unique value
				;	RSX11-D		 0.
				;	RSX11-M		 1.
				;	RSX11-S		 2.
				;	IAS		 3.
				;	RSTS/E V7	 4.
				;	VMS		 5.
				;	RSX11-M+	 6.		;10
				;	RT11		 7.
				;	P/OS		 9.

$$rsts::
	.word	0		;Set non-zero on RSTS/E	
$$tsxp::								;12
	.word	0		;Set non-zero on TSX-Plus		;12
$$vms::									;06
	.word	0		;Set non-zero on VMS			;06
$$pos::
	.word	0		;Set non-zero on P/OS			;10
$$tick::								;07+
	.word	60.		;Set to 50 (on RT11) by $$init if
				;necessary.  Reset on calls to time()
				;and ftime() on RSX			;07-
$$stnd::
	.blkw	1		;High-point of stack
$$argc::
	.word	0		;Number of command args
$$argv::
	.word	0		;-> argv[]
$$mend::								;05+
	.word	0		; End of untouched memory
$$mlim::
	.limit			; Memory limits
$$mtop	==	$$mlim+2	; We need first byte unused		;05-


.if ne rsx
;
; RSX-specific global data.
;
$$uic::
	.blkw	1		;Task default uic from GTSK$

$$task::
	.ascii	"??????"	;Gets the task name
	.byte	0		;Null terminated.
.iff
;
; RT11-specific global data.
;

$$scca::
	.word	0		;Set non-zero if CTRL/C typed
.endc
	.even

;									;11+
; Stuff for initializers - must declare all three psects in order!
;
	.psect	$init
init:				;Start of initializer list
	.word	$$init		;$$init() is the first initializer
	.psect	$init$		;The list itself
	.psect	$init.
inite:				;End of the initializer list		;11-

	.psect	c$code
;
; Run time startoff.
; Called from the operating system
;

.if eq	rsx
	nop			;Dummy reenter address
.endc
$$main::
	mov	sp,$$stnd	;Save end of stack
	clr	r5		;No environment linkage yet
;									;11+
; Call $$init() to set up the state of the world, and then call the user's
; initializers.
;
; Warning:  The following code depends on two facts:
;		- There is always at least on initializer ($$init())
;		- This code cannot be entered except by flowing into it.
;	    If either of these may be false, a branch should be added to
;	    start the loop at the cmp, to ensure that r2 points to a valid
;	    address.
;
; Note:  You may wonder why main() isn't called in the initializer loop.
; The problem is the arguments that must be passed to main.  If we push
; them on the stack BEFORE the loop, they are incorrect, since $$argc and
; and $$argv are set up by $$init(), which is called in the loop.  So
; we'd have to push and pop them each time around the loop - which costs
; more than the separate call.  (Besides, $$init() is, logically, an ini-
; tializer; main() is not.)
;
	mov	#init,r2	;-> First initializer
10$:
	call	@(r2)+		;Call the next initializer
	cmp	r2,#inite	;Any more?
	blo	10$		;Do them, too
									;11-
	clr	-(sp)		;No environment				;08
	mov	$$argv,-(sp)	;Arg. vector
	mov	$$argc,-(sp)	;Arg. count
	call	main		;Off we go
	mov	#E$$XOK,-(sp)	;Normal exit				;09
	call	exit		;Normal exit				;09
	crash			;Can't happen				;09
	.end	$$main

-h- init.fix	Mon Sep 17 15:45:23 1984	init.fix
; This is a section of INIT.MAC. The changes concern the brief sequence
; needed to establish whether the system is running under TSX-Plus. This
; is othwerwise unchanged from INIT.MAC ident 38.
.iff
;
; RT11 specific code:  check if it's really either TSX-Plus or RSTS/E
; emulation.  Then do an incredable hack on RSTS to find the command line.
; This code has been heavily reorganized -- edit numbers <39 were removed.
;
	mov	@#HIMEM,r1	; Save top of memory
	inc	r1		; Push it up
	bic	#1,r1		; to the first free byte
	mov	r1,$$mend	; and save it.
;;	bis	#TTLC$,@#JSW	; set lower-case bit (in asect)
	clr	(sp)		; No task name hack needed
	mov	#$$argv,-(sp)	; Where argv[] goes
	mov	#$$ofil,-(sp)	; where stdout redirection goes
	mov	#$$ifil,-(sp)	; Where stdin redirection goes
	mov	#defcmd,-(sp)	; Default command line
	mov	#clibuf,r2	; User supplied Argv line
	cmp	-(sp),-(sp)	; Get temp for .gval
	mov	sp,r1		; R1 -> .gval pmtr. block
	.gval	r1,#CNFIG1	; Get configuration word 1
	bit	#40,r0		; Bit 5, set if 50 Hertz
	beq	10$		; Br if 60 Hertz
	mov	#50.,$$tick	; Set 50 Hertz clock
;									;39+
; Check if it's TSX-Plus
; ***** NOTE: Not tested under RSTS emulation
;
	.mcall	.serr,.herr
10$:	.serr			; Stop aborts from other systems
	mov	#12$,r0		; Set for the EMT
	emt	375		; Do it
	bcs	11$		; Not TSX if an error
	mov	r0,$$tsxp	; We might as well use the line number
11$:	.herr			; Reenable heavy-duty aborts
	br	13$		; Proceed
12$:	.byte	0,110		; TSX-Plus line-number emt
13$:									;39-
;
; Note: someday, we may have to test for RT11 emulation on vms, too.
;
	.gval	r1,#0		; Get first word of RMON
	tst	r0		; It's non-zero on native RT11 or TSX-Plus
	bne	30$		; Branch if so.
;
; Setup for RSTS/E
;
	inc	$$rsts		; zero means rsts/e, set flag
;
; Under RSTS/E, we have to trap CTRL/Z so stdio can return EOF
;
	.scca	r1,#$$scca	; Call with non-zero argument
;									;31+
; Dump the RT11 emulator's local buffer.  Note that this is somewhat
; undocumented.
;
14$:	.gval	r1,#TTICNT	;Anything in the buffer?
	tst	r0		;Well?
	beq	18$		;Exit if nothing there
	.ttyin			;Get the byte
	br	14$		;Go for another
18$:				;Main sequence				;31-
;
; Look for something in core common.
;
	mov	@#R.PARM,r1	;Yes, grab .run line number
	bic	#100000,r1	;Ignore "retain privileges"
	cmp	#29000.,r1	;At the magic line or better?
	bgt	30$		;He's not a wizard, then
	mov	#CORCMN,r1	;Yes, r1 -> core common buffer
	clr	r2		;Get common length
	bisb	(r1)+,r2	;r2 := number of bytes in common
	beq	40$		;If zero, common is empty
	mov	#defcmd,r3	;Common exists, get a buffer copy
20$:	movb	(r1)+,(r3)+	;Copy bytes to local buffer
	dec	r2		;Counting them all the while
	bne	20$		;Keep on trucking
	br	40$		;Continue main sequence
;
; Here for native RT11 or to prompt for a command on RSTS/E RT11
;
30$:				; Here to prompt on RSTS/E, too
	tst	$$narg		; Don't ask for "Argv: " if set
	bne	40$		; Br if user set the flag
	mov	#defcmd,r1	; Presuppose "Argv:" prompt	;36/38+
	mov	$$prmt,r0	; User's prompt if non NULL
	beq	32$		; NULL, use our's
	mov	r0,r1		; r1 -> prompt start
31$:	tstb	(r0)+		; Skip to the end
	bne	31$		; All the way.
	movb	#200,-(r0)	; Make it 200 for rt11 prompt
32$:	.rctrlo			; Refresh lc bit (SPR 11-35833)
;
; There is a bug in .gtlin on RSTS/E V7.1.  Therefore, we use .ttyin	;29+
; to read the line.  On entry, r2 -> command line, r1 -> prompt
;
34$:	tst	$$rsts		; On native rt11?
	bne	35$		; Br if not
	.gtlin	r2,r1		; Get the line (with prompt)
	br	40$		; Main sequence.			;38-
;
; RSTS/E only -- get the byte using .ttyin
;
35$:
	.print	r1		; Prompt first
3501$:
	.ttyin			; Get a byte
	cmpb	r0,#CR		; Return?
	beq	3501$		; Skip it if so
	cmpb	r0,#LF		; Linefeed
	beq	36$		; Exit if so
	movb	r0,(r2)+	; Output the byte
	cmp	r2,#cliend-1	; Too far?				;35
	blo	3501$		; No, get the next byte		;36-;38-
36$:	clrb	(r2)		; Terminate the line			;29-

40$:
	cmp	(sp)+,(sp)+	; Pop .gval and .scca temp
.endc									;RT11-

-h- fwild.fix	Mon Sep 17 15:45:23 1984	fwild.fix
; This is a modification of the RT11 code from FWILD.MAC. There was an error
; that prevented the function from finding a wildcarded file if it was the
; first one in a directory segment. The fix is not beautiful, but it works.
; This is a section of FWILD.MAC, otherwise identical to FWILD ident 16.
;
fscan1:
	mov	V$WFLG(r4),-(sp)	; Copy of flag for check below	;17
fscn1a:									;17
	mov	W.DSEG(r3),r1		; Compute lbn of segment
	beq	done			; Exit if at directory end
	asl	r1
	add	#DOFSET,r1
	clr	-(sp)			; Build .readw parameter block
	mov	#512.,-(sp)		; r0 ->	! 10  ! chan!
	mov	V$BASE(r4),-(sp)	;	!    blk    !
	mov	r1,-(sp)		;	!    buf    !
	mov	V$LUN(r4),-(sp)		;	!   wcnt    !
	add	#<400*10>,(sp)		;	!     0     !
	mov	sp,r0			; r0 -> argument block
	emt	375			; .READW
	bcs	nogood			; br if error reading directory
	add	#<5*2>,sp		; Clean off the stack
	mov	#L.ENTR,r0		; Std dir. entry size = 7 words
	mov	V$BASE(r4),r2		; r2 --> directory header	;16
	add	D.EXTR(r2),r0		; Add in extra bytes per entry
	mov	r0,W.ESIZ(r3)		; Store entry size in wdb
	cmp	(sp)+,V$WFLG(r4)	; Are we here from fscan3?	;17
	bne	fscan2			; Yes, do not skip 1st entry	;17
	bit	#VF$WF1,V$WFLG(r4)	; Second time through		;15
	bne	fscan3			; Yes, step to next entry
	bis	#VF$WF1,V$WFLG(r4)	; No set flag for next time.	;15
fscan2:
-h- screen.fix	Mon Sep 17 15:45:23 1984	screen.fix
; This contains a number of changes for the SCREEN.MAC module, mostly concerned
; with recognizing terminals of the VT52/100 families like VT55s, VT102s and
; VT125s, as well as some non-DEC terminals with funny answerbacks. There is
; also a change that uses the TSX-Plus terminal type if that is set to be
; VT52 or VT100. This is the tail of SCREEN.MAC, otherwise identical to
; SCREEN.MAC ident 08. The fix was done in two stages, hence the use of ident
; numbers 09 and 10.
;
.iff
;
; RT11 is a mess.  TSX-Plus is a little better, so check first to see if
; it's in use.  The following is mostly from the Software Support manual.
;
	call	tsxset			; Check if TSX+ knows		;09
	tst	r4			; If true, r4 will be nonzero	;09
	bne	gotcha			; He did! Else go the hard way	;09
	mov	@#30,r0			; R0 -> EMT handler !
	tst	-(r0)			; The terminal status
	bpl	gotcha			; Positive means nothing
	mov	@#44,-(sp)		; Save JSW
	bis	#10100,@#44		; Set bits 6 and 12		;09
	.print	#ident			; Ask for identification	;02
	.ttyin				; Look for a recognizable reply
	bic	#177600,r0		; Remove parity, junk		;02
	cmp	r0,#ESC&177		; Escape
	bne	rgotit			; Urk
	.ttyin				; Get the signal		;02
	cmp	r0,#'/			; VT52 mode?
	bne	30$			; No, try for ANSI
	.ttyin				; What's next
	tst	(r4)+
	cmp	r0,#'K			; VT52
	beq	rgotit
	cmp	r0,#'E			; VT55
	beq	rgotit
	cmp	r0,#'L			; Visual 500			;09
	beq	rgotit							;09
	cmp	r0,#'Z			; VT100 in VT52 mode
	beq	rgotit
	tst	-(r4)			; Urk, back to zero		;02
	br	rgotit			; Just exit

30$:
	cmp	r0,#'[			; Ansi leadin?
	bne	rgotit			; Nope
	.ttyin
	cmp	r0,#'?			;
	bne	rgotit			; Urk
	.ttyin				;				;02+
	cmp	r0,#'1			; VT100 is a
	beq	35$			; type one terminal
	cmp	r0,#'6			; VT102 is a
	beq	35$			; type six terminal (also VT125)
	br	rgotit
35$:	.ttyin				; Scrub rest of message till	;09
	cmp	r0,#'c			;  (note) lowercase c
	bne	35$			; Urk
	cmp	(r4)+,(r4)+		; VT100 ANSI, r4 := 4		;02
;
rgotit:
	mov	(sp)+,@#44		; Reset old JSW			;02
.endc

gotcha:
	mov	r4,$$ttyp
;	br	doinit			; Put the terminal in the mode	;05+
;
; ** DOINIT **
;
; Force the terminal into the correct mode.  This is necessary as VT100's
; can be in VT52 or ANSI mode.  The init(r4) string sets up the VT100.
;
; Entry:
;	r4	Contains the terminal type index
;
; Uses:
;	r0,r1,r2
;

doinit:					; NOTE: called by scsettype()	;03
	mov	init(r4),r0
	call	outstr							;03
	callr	oflush			; Flush needed for VT100's	;03

.if eq rsx								;09
;
; ** TSXSET **								;09/10
;
; Find out if we're running under TSX-Plus. If true, find out whether
; it knows whether it has a vt52 or vt100. Use the id if we can, else request
; single-character activation mode and return for RT-11-style enquiry.
;
tsxset:
	tst	$$tsxp			; $$init finds out for us
	beq	1$			; Not TSX, skip
	mov	#tsxtrm,r0		; Get terminal type
	emt	375			; Do it
	tst	r0			; What is it?
	beq	2$			; Unknown: we gotta check it
	cmp	r0,#2			; Is it a type we understand?
	ble	2$			; Yes, use it
	clr	r0			; Nope, zap it
2$:	asl	r0			; Use the TSX-Plus value
	mov	r0,r4			;  for our ID
	.print	#tsxsca			; Ask for single-char-activation
1$:	return

tsxtrm:	.byte	0,137			; EMT to get terminal id
tsxsca:	.byte	35,'S,200		; String to request sca mode
.even
.endc
	.end


