.IIF	NDF	RSX	RSX	=	1	;Assume RSX	;01+
	.TITLE	CC207
	.ident	/X01.U2/

	.NLIST	BEX, CND
	.ENABL	LC, GBL
	.LIST	MEB						;01 -

;
; C COMPILER.
; DEBUG.
;
; VERSION X01
;
; DAVID G. CONROY		23-MAY-79
;
; Edit history
; 01 04-Mar-80 MM	Added RT11 support
; 02 03-Jun-80 MM	Globalized table names for debugging
; 03 05-Mar-81 MM	Added dump of register field, etc.
;			(Unimation sources were identical)
; u1 21-Jul-82 CCG	Removed OP.CVM references, added OP.MLL and OP.DLL
; u2 30-Jan-02 BQT	Added void type.
;

	.GLOBL	OPNAME						;02
	.GLOBL	TYNAME						;02

.IF NE	RSX							;01
	.MCALL	CALLR
.ENDC								;01

	.GLOBL	TDUMP
	.GLOBL	TDUMPX

;
; #DEFINES
; ASSEMBLER STYLE.
;

STEP	=	4		;INDENT STEP SIZE

;
; LOCAL DATA.
;

LEVEL:	.BLKW	1		;INDENT LEVEL

;
; OPERATOR NAMES.
; UP TO OP.SEM
;

OPNAME:	.ASCII	"EOF"		;END OF FILE
	.ASCII	"CON"		;CONSTANT (ALL TYPES)
	.ASCII	"ID "		;ID (EXTERNALS)
	.ASCII	"LID"		;LOCAL ID (STATICS)
	.ASCII	"LCN"		;LONG CONSTANT (SCANNER)
	.ASCII	"DCN"		;DOUBLE CONSTANT (SCANNER)
	.ASCII	"REG"		;REGISTER
	.ASCII	"INX"		;XXX(REG)
	.ASCII	"AUI"		;(REG)+
	.ASCII	"AUD"		;-(REG)
	.ASCII	"ADD"		;+
	.ASCII	"SUB"		;- BINARY
	.ASCII	"MUL"		;* BINARY
	.ASCII	"DIV"		;/
	.ASCII	"MOD"		;%
	.ASCII	"ASL"		;<<
	.ASCII	"ASR"		;>>
	.ASCII	"AND"		;& BINARY
	.ASCII	"OR "		;OR
	.ASCII	"XOR"		;^
	.ASCII	"ADA"		;+=
	.ASCII	"SBA"		;-=
	.ASCII	"MUA"		;*=
	.ASCII	"DVA"		;/=
	.ASCII	"MOA"		;%=
	.ASCII	"ALA"		;<<=
	.ASCII	"ARA"		;>>=
	.ASCII	"ANA"		;&=
	.ASCII	"ORA"		;OR=
	.ASCII	"XRA"		;^=
	.ASCII	"EQ "		;==
	.ASCII	"NE "		;!=
	.ASCII	"LT "		;<
	.ASCII	"LE "		;<=
	.ASCII	"GE "		;>=
	.ASCII	"GT "		;>
	.ASCII	"LTU"		;<  UNSIGNED
	.ASCII	"LEU"		;<= UNSIGNED
	.ASCII	"GEU"		;>= UNSIGNED
	.ASCII	"GTU"		;>  UNSIGNED
	.ASCII	"AA "		;LOGICAL AND
	.ASCII	"OO "		;LOGICAL OR
	.ASCII	"INB"		;++ PREFIX
	.ASCII	"INA"		;++ POSTFIX
	.ASCII	"DEB"		;-- PREFIX
	.ASCII	"DEA"		;-- POSTFIX
	.ASCII	"ASG"		;ASSIGNMENT
	.ASCII	"ADR"		;& UNARY
	.ASCII	"IND"		;* UNARY
	.ASCII	"NEG"		;- UNARY
	.ASCII	"COM"		;TILDE
	.ASCII	"NOT"		;!
	.ASCII	"QRY"		;?
	.ASCII	"CLN"		;:
	.ASCII	"CMA"		;, IN ARGLISTS.
	.ASCII	"SEQ"		;SEQUENTIAL EXECUTION
	.ASCII	"BIC"		;BIT CLEAR
	.ASCII	"BCA"		;ASSIGNED BIT CLEAR
	.ASCII	"BIT"		;BIT TEST
	.ASCII	"JSR"		;CALL
	.ASCII	"CVR"		;CONVERT TO REGISTER
	.ASCII	"MLL"		;SPECIAL LONG MULTIPLY
	.ASCII	"FLD"		;FIELD SPEC.
	.ASCII	"COT"		;CAST OF TYPES.
	.ASCII	"LOD"		;LOAD
	.ASCII	"CST"		;NULL TERMINATED STRING
	.ASCII	"DLL"		;SPECIAL LONG DIVIDE (pass 2 only)
	.ASCII	"!!!"		;JUNK

;
; TYPE NAMES.
;

TYNAME:	.ASCII	"und"		;TY.UND
	.ASCII	"chr"		;TY.CHR
	.ASCII	"int"		;TY.INT
	.ASCII	"uns"		;TY.UNS
	.ASCII	"ptr"		;TY.PTR
	.ASCII	"voi"		;TY.VOI
	.ASCII	"lng"		;TY.LNG
	.ASCII	"flt"		;TY.FLT
	.ASCII	"dbl"		;TY.DBL
	.ASCII	"ust"		;TY.UST
	.ASCII	"uun"		;TY.UUN
	.ASCII	"str"		;TY.STR
	.ASCII	"uni"		;TY.UNI

;
; OTHER STRINGS.
;

LEADIN:	.ASCIZ	"/"<12>		;INITIAL COMMENTARY			;03
HFSTR:	.ASCIZ	" hfpr="	;HIGHEST F.P. REGISTER
HGSTR:	.ASCIZ	" hgpr="	;HIGHEST G.P. REGISTER
WNAME:	.ASCIZ	" width="	;FOR FIELDS
BNAME:	.ASCIZ	" bit="		;FOR FIELDS
NNAME:	.ASCIZ	"[Null]"	;FOR NULL TREES
RNAME:	.ASCIZ	" result reg = r?"	; RESULT REGISTER NAME		;03
RESREG	=	RNAME+15.						;03
	.EVEN

;+
; ** TDUMP -- DUMP A TREE IF -L INVOCATION
; ** TDUMP -- DUMP A TREE ALWAYS (PROBABLY BECAUSE OF A CRASH)
;
; THIS ROUTINE DUMPS AN EXPRESSION TREE, NICELY FORMATTED, TO THE CODE
; STREAM AS COMMENTS. THE CODE STREAM WAS CHOSEN SO THAT THE TREE  AND
; THE GENERATED CODE COULD BE SEEN AT ONCE.
;
; THE TREE GOES OUT WITH THE RIGHT SUBTREE TOWARDS THE TOP OF THE PAGE
; AND THE LEFT SUBTREE TOWARD THE BOTTOM OF THE PAGE. EACH  TREE LEVEL
; IS INDENTED BY FOUR SPACES.
;
; INPUTS:
;	R5=TREE.
;-

	.ENABL	LSB

TDUMP:	TSTB	LFLAG		;WELL?
	BEQ	5$		;NOPE

TDUMPX:									;03
	JSR	R5,SAVREG	;SAVE REGISTERS				;03
	MOV	#LEADIN,R0	;LEADING				;03
	CALL	CODSTR		;COMMENT				;03
	CLR	LEVEL		;START INDENT LEVEL
	CALL	10$		;DO IT.
	MOV	#LEADIN,R0	;TRAILING				;03
	CALL	CODSTR		;LINE

5$:	RETURN			;DONE

;
; THE PART THAT DOES ALL THE WORK.
;

10$:	TST	R5		;NULL TREE?
	BNE	20$		;NO.
	CALL	BEGIN		;BEGINNING STUFF.
	MOV	#NNAME,R0	;SAY "NULL"
	CALL	CODSTR		;
	CALL	CODNL		;
	JMP	130$		;DONE

20$:	CMP	(R5),#OP.ADD	;LEAF NODE?
	BLO	30$		;YES.
	MOV	R5,-(SP)	;SAVE TREE
	ADD	#STEP,LEVEL	;DO
	MOV	E.ROP(R5),R5	;THE
	CALL	10$		;RIGHT
	SUB	#STEP,LEVEL	;TREE
	MOV	(SP)+,R5	;RESTORE TREE

30$:	CALL	BEGIN		;DO THE BEGINNING
	MOV	(R5),R0		;GET OP
	CMP	R0,#OP.SEM	;IS IT A GOOD ONE?
	BLO	40$		;YES.
	MOV	#OP.SEM,R0	;FORCE GOOD.

;
; NOTE: IF THIS CODE IS CHANGED, CHANGE THE CORRESPONDING CODE IN CC202
;
40$:	MOV	R0,R1		;COMPUTE
	ASL	R0		;3 *
	ADD	R0,R1		;OPERATOR.
	ADD	#OPNAME,R1	;POINT AT THE NAME.
	MOVB	(R1)+,R0	;PUT
	CALL	CODC		;OUT
	MOVB	(R1)+,R0	;THE
	CALL	CODC		;NAME
	MOVB	(R1)+,R0	;OF THE
	CALL	CODC		;OP
	CALL	CODSP		;A SPACE

	MOVB	E.TYPE(R5),R1	;GET TYPE
	MOV	R1,R0		;* 3
	ASR	R0		;(TYPE / 2) * 3
	ADD	R0,R1		;
	ADD	#TYNAME,R1	;NAME OF TYPE.
	MOVB	(R1)+,R0	;PUT
	CALL	CODC		;OUT
	MOVB	(R1)+,R0	;THE
	CALL	CODC		;NAME
	MOVB	(R1)+,R0	;OF THE
	CALL	CODC		;TYPE

	MOV	#HFSTR,R0	;HFPR=
	CALL	CODSTR		;
	MOVB	E.HFPR(R5),R0	;AND THE
	CALL	CODNUM		;COUNT

	MOV	#HGSTR,R0	;HGPR=
	CALL	CODSTR		;
	MOVB	E.HGPR(R5),R0	;AND THE
	CALL	CODNUM		;COUNT

	CMP	(R5),#OP.ADD	;IS IT AN OPERATION?			;03+
	BLO	42$		;NO, CAN'T HAVE A REGISTER
	MOVB	#'?,RESREG	;YES, PRESUPPOSE "ANY"
	MOVB	E.REG(R5),R0	;GET REGISTER VALUE
	BMI	41$		;-1 => ANY WILL DO
	ADD	#'0,R0		;LOCATE IT AS ASCII
	CMP	R0,#'7		;TOO FAR?
	BGT	41$		;YES, STILL ?
	MOVB	R0,RESREG	;AND STUFF IT AWAY
41$:
	MOV	#RNAME,R0	;WHAT TO PRINT
	CALL	CODSTR		;DO IT
42$:				;					;03-

	CMP	(R5),#OP.CON	;CONSTANT?
	BNE	50$		;NO.					;03
	MOV	R5,R1		;POINT AT
	ADD	#E.VAL,R1	;THE CONSTANT VALUE
	MOVB	E.TYPE(R5),R2	;GET CONSTANT TYPE.
	CALL	CODSP		;ONE WORD
	MOV	(R1)+,R0	;
	CALL	CODNUM		;
	CMP	R2,#TY.LNG	;IF ONE WORD
	BLO	120$		;DUCK.
	CALL	CODSP		;ONE WORD
	MOV	(R1)+,R0	;
	CALL	CODNUM		;
	CMP	R2,#TY.DBL	;IF TWO WORD
	BLO	120$		;DUCK.
	CALL	CODSP		;LAST TWO WORDS
	MOV	(R1)+,R0	;
	CALL	CODNUM		;
	CALL	CODSP		;
	MOV	(R1),R0		;
	CALL	CODNUM		;
	BR	120$		;DONE

50$:	CMP	(R5),#OP.ID	;ID?					;03
	BNE	60$		;NO.					;03
	CALL	CODSP		;SPACE
	MOV	R5,R0		;PUT OUT
	ADD	#E.NAME,R0	;THE NAME
	CALL	CODSTR		;OF THE EXTERNAL
	CALL	OFFSET		;FORMAT OFFSET
	BR	120$		;DONE

60$:	CMP	(R5),#OP.LID	;LID?					;03
	BNE	70$		;NO.
	CALL	CODSP		;SPACE
	MOV	E.LAB(R5),R0	;DO THE
	CALL	CODLAB		;LABEL.
	CALL	OFFSET		;FORMAT OFFSET
	BR	120$		;DONE


70$:	CMP	(R5),#OP.REG	;REGISTER?
	BNE	80$		;NO.
	CALL	CODSP		;SPACE
	CALL	DOREG		;YES, DO IT.
	BR	120$		;DONE

80$:	CMP	(R5),#OP.INX	;INDEXING?
	BNE	90$		;NO
	CALL	CODSP		;SPACE
	CALL	OFFSET		;PUT OUT OFFSET.
	CALL	DOPREG		;(REG)
	BR	120$		;DONE

90$:	CMP	(R5),#OP.AUI	;AUTOINCREMENT?
	BNE	100$		;NO.
	CALL	CODSP		;SPACE
	CALL	DOPREG		;THE REGISTER
	MOV	#'+,R0		;THE "+"
	CALL	CODC		;
	BR	120$		;DONE

100$:	CMP	(R5),#OP.AUD	;AUTODECREMENT?
	BNE	110$		;NO.
	CALL	CODSP		;SPACE
	MOV	#'-,R0		;PUT OUT "-"
	CALL	CODC		;
	CALL	DOPREG		;THE REG.
	BR	120$		;DONE.

110$:	CMP	(R5),#OP.FLD	;FIELD?
	BNE	120$		;NO
	MOV	#WNAME,R0	;WIDTH=
	CALL	CODSTR		;
	MOVB	E.WIDE(R5),R0	;THE WIDTH
	CALL	CODNUM		;
	MOV	#BNAME,R0	;BOFS=
	CALL	CODSTR		;
	MOVB	E.BOFS(R5),R0	;THE BOFS
	CALL	CODSTR		;

120$:	CALL	CODNL		;THE NEWLINE.

	CMP	(R5),#OP.ADD	;LEAF NODE?
	BLO	130$		;YES.
	MOV	R5,-(SP)	;SAVE TREE
	ADD	#STEP,LEVEL	;ADJUST LEVEL.
	MOV	E.LOP(R5),R5	;LEFT
	CALL	10$		;SUBTREE.
	SUB	#STEP,LEVEL	;BACK UP.
	MOV	(SP)+,R5	;RESTORE TREE.

130$:	RETURN			;DONE

	.DSABL	LSB
;+
; ** BEGIN -- STUFF AT THE BEGINNING.
;-

BEGIN:	MOV	#'/,R0		;PUT OUT
	CALL	CODC		;THE
	CALL	CODSP		;STUFF AT THE START.

	MOV	R5,R1		;GET TREE ADDRESS
	MOV	#'0,R0		;DO
	ASL	R1		;TOP
	ADC	R0		;OCTAL
	CALL	CODC		;DIGIT
	MOV	#5,R2		;5 DIGITS
10$:	MOV	#6,R0		;MAKE DIGIT
	ASL	R1		;
	ROL	R0		;
	ASL	R1		;
	ROL	R0		;
	ASL	R1		;
	ROL	R0		;
	CALL	CODC		;PUT IT OUT
	DEC	R2		;LOOP
	BNE	10$		;

	MOV	LEVEL,R1	;GET SIZE OF GAP
	INC	R1		;+1 FOR GAP

30$:	CALL	CODSP		;PUT
	DEC	R1		;OUT
	BNE	30$		;SPACES

	RETURN			;DONE

;+
; ** OFFSET -- OUTPUT OFFSET.
;
; THIS ROUTINE OUTPUTS THE OFFSET FIELD OF A TREE NODE. THIS FIELD IS
; PRINTED AS A SIGNED OCTAL INTEGER. NOTHING GOES OUT IF  THE  OFFSET
; IS ZERO.
;
; INPUTS:
;	R5=TREE.
;
; USES:
;	R0, R1
;-

OFFSET:	MOV	#'+,R0		;DEFAULT SIGN.
	MOV	E.OFFS(R5),R1	;GRAB OFFSET.
	BEQ	20$		;DUCK ON ZERO.
	BPL	10$		;ALL SET IF POSITIVE.
	NEG	R1		;FIX.
	MOV	#'-,R0		;GET CORRECT SIGN.
10$:	CALL	CODC		;THE SIGN.
	MOV	R1,R0		;AND
	CALL	CODNUM		;THE OFFSET.
20$:	RETURN			;DONE.

;+
; ** DOPREG -- REGISTER IN PARENS.
;
; THIS ROUTINE FORMATS THE REGISTER NUMBER OF INDEX, AUTOINCREMENT AND
; AUTODECREMENT NODES.
;
; INPUTS:
;	R5=TREE.
;
; USES:
;	R0, R1
;-

DOPREG:	MOV	#'(,R0		;OPEN PAREN.
	CALL	CODC		;
	CALL	DOREG		;THE REGISTER.
	MOV	#'),R0		;CLOSE PAREN.
	CALLR	CODC		;DONE

;+
; ** DOREG -- FORMAT REGISTER.
;
; INPUTS:
;	R5=TREE.
;
; USES:
;	R0
;-

DOREG:	MOV	#'r,R0		;REGISTER
	CALL	CODC		;
	MOV	E.REG(R5),R0	;REGISTER NUMBER
	ADD	#'0,R0		;TO ASCII
	CALLR	CODC		;OUT

	.END
