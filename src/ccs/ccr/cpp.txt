
        1.0  C Pre-Processor



                                    *******
                                    * cpp *
                                    *******



        NAME:   cpp -- C Pre-Processor

        SYNOPSIS:

                cpp [-options] [infile [outfile]]

        DESCRIPTION:

                CPP reads a C source file, expands  macros  and  include
                files,  and writes an input file for the C compiler.  If
                no file arguments are given, CPP reads  from  stdin  and
                writes  to  stdout.   If  one file argument is given, it
                will define the input file,  while  two  file  arguments
                define  both  input and output files.  The file name "-"
                is a synonym for stdin or stdout as appropriate.

                The following options are  supported.   Options  may  be
                given in either case.

                -C              If set, source-file comments are written
                                to  the  output  file.   This allows the
                                output of CPP to be used as the input to
                                a  program,  such  as lint, that expects
                                commands embedded in specially-formatted
                                comments.

                -Dname=value    Define the name  as  if  the  programmer
                                wrote

                                    #define name value

                                at the start  of  the  first  file.   If
                                "=value"  is  not  given, a value of "1"
                                will be used.

                                On non-unix systems, all alphabetic text
                                will be forced to upper-case.

                -E              Always return "success" to the operating
                                system,  even  if  errors were detected.
                                Note that some fatal errors, such  as  a
                                missing  #include  file,  will terminate
                                CPP, returning "failure" even if the  -E
                                option is given.
                                                                          Page 2
        cpp     C Pre-Processor


                -Idirectory     Add  this  directory  to  the  list   of
                                directories  searched for #include "..."
                                and #include <...> commands.  Note  that
                                there  is  no space between the "-I" and
                                the directory string.  More than one  -I
                                command   is   permitted.   On  non-Unix
                                systems   "directory"   is   forced   to
                                upper-case.

                -N              CPP  normally  predefines  some  symbols
                                defining   the   target   computer   and
                                operating system.  If -N  is  specified,
                                no symbols will be predefined.  If -N -N
                                is  specified,  the   "always   present"
                                symbols,    __LINE__,    __FILE__,   and
                                __DATE__ are not defined.

                -Stext          CPP normally assumes that  the  size  of
                                the  target  computer's  basic  variable
                                types is the same as the size  of  these
                                types  of  the host computer.  (This can
                                be  overridden  when  CPP  is  compiled,
                                however.)  The  -S option allows dynamic
                                respecification of these values.  "text"
                                is  a  string  of  numbers, separated by
                                commas, that  specifies  correct  sizes.
                                The sizes must be specified in the exact
                                order:

                                    char short int long float double

                                If you specify the option as  "-S*text",
                                pointers   to   these   types   will  be
                                specified.   -S*  takes  one  additional
                                argument  for  pointer to function (e.g.
                                int (*)())

                                For   example,    to    specify    sizes
                                appropriate  for  a  PDP-11,  you  would
                                write:

                                       c s i l f d func
                                     -S1,2,2,2,4,8,
                                    -S*2,2,2,2,2,2,2

                                Note that all values must be specified.

                -Uname          Undefine the name as if

                                    #undef name

                                were given.  On non-Unix systems, "name"
                                will be forced to upper-case.
                                                                          Page 3
        cpp     C Pre-Processor


                -Xnumber        Enable debugging code.  If no  value  is
                                given,  a value of 1 will be used.  (For
                                maintenence of CPP only.)


        PRE-DEFINED VARIABLES:

                When CPP begins processing, the following variables will
                have been defined (unless the -N option is specified):

                Target computer (as appropriate):

                    pdp11, vax, M68000 m68000 m68k

                Target operating system (as appropriate):

                    rsx, rt11, vms, unix

                Target compiler (as appropriate):

                    decus, vax11c

                The implementor may add definitions to this  list.   The
                default  definitions  match  the  definition of the host
                computer, operating system, and C compiler.

                The following are always available unless undefined  (or
                -N was specified twice):

                    __FILE__    The  input  (or  #include)  file   being
                                compiled (as a quoted string).

                    __LINE__    The line number being compiled.

                    __DATE__    The date and time of  compilation  as  a
                                Unix  ctime  quoted string (the trailing
                                newline is removed).  Thus,

                                    printf("Bug at line %s,", __LINE__);
                                    printf(" source file %s", __FILE__);
                                    printf(" compiled on %s", __DATE__);


        DRAFT PROPOSED ANSI STANDARD CONSIDERATIONS:

                The current  version  of  the  Draft  Proposed  Standard
                explicitly  states  that  "readers  are requested not to
                specify or claim conformance to this draft." Readers and
                users  of  Decus  CPP  should  not assume that Decus CPP
                conforms to the standard, or that it will conform to the
                actual C Language Standard.

                When CPP is itself compiled, many features of the  Draft
                Proposed  Standard  that  are incompatible with existing
                                                                          Page 4
        cpp     C Pre-Processor


                preprocessors may be  disabled.   See  the  comments  in
                CPP's source for details.

                The latest version of the Draft  Proposed  Standard  (as
                reflected in Decus CPP) is dated November 12, 1984.

                Comments are removed from the input text.   The  comment
                is  replaced by a single space character.  The -C option
                preserves comments, writing them to the output file.

                The '$' character is considered to be a letter.  This is
                a permitted extension.

                The following new features of C are processed by CPP:

                    #elif expression (#else #if)
                    '\xNNN' (Hexadecimal constant)
                    '\a' (Ascii BELL)
                    '\v' (Ascii Vertical Tab)
                    #if defined NAME 1 if defined, 0 if not
                    #if defined (NAME) 1 if defined, 0 if not
                    #if sizeof (basic type)
                    unary +
                    123U, 123LU Unsigned ints and longs.
                    12.3L Long double numbers
                    token#token Token concatenation
                    #include token Expands to filename

                The Draft Proposed Standard has  extended  C,  adding  a
                constant string concatenation operator, where

                    "foo" "bar"

                is regarded as the single string "foobar".   (This  does
                not  affect  CPP's  processing but does permit a limited
                form of macro argument substitution into strings as will
                be discussed.)

                The Standard Committee plans to add token  concatenation
                to  #define command lines.  One suggested implementation
                is as follows:  the sequence "Token1#Token2" is  treated
                as  if  the programmer wrote "Token1Token2".  This could
                be used as follows:

                    #line 123
                    #define ATLINE foo#__LINE__

                ATLINE would be defined as foo123.

                Note that "Token2" must either have  the  format  of  an
                identifier or be a string of digits.  Thus, the string

                    #define ATLINE foo#1x3
                                                                          Page 5
        cpp     C Pre-Processor


                generates two tokens:  "foo1" and "x3".

                If the tokens T1 and T2 are concatenated into  T3,  this
                implementation operates as follows:

                  1. Expand T1 if it is a macro.
                  2. Expand T2 if it is a macro.
                  3. Join the tokens, forming T3.
                  4. Expand T3 if it is a macro.

                A macro formal parameter  will  be  substituted  into  a
                string or character constant if it is the only component
                of that constant:

                    #define VECSIZE 123
                    #define vprint(name, size) \
                      printf("name" "[" "size" "] = {\n")
                      ... vprint(vector, VECSIZE);

                expands (effectively) to

                      vprint("vector[123] = {\n");

                Note that  this  will  be  useful  if  your  C  compiler
                supports  the  new  string concatenation operation noted
                above.  As implemented here, if you write

                    #define string(arg) "arg"
                      ... string("foo") ...

                This implementation generates  "foo",  rather  than  the
                strictly  correct  ""foo"" (which will probably generate
                an error message).  This is, strictly speaking, an error
                in CPP and may be removed from future releases.

        ERROR MESSAGES:

                Many.  CPP prints warning or error messages if  you  try
                to     use     multiple-byte     character     constants
                (non-transportable) if you #undef a symbol that was  not
                defined,  or  if  your  program  has  potentially nested
                comments.

        AUTHOR:

                Martin Minow

        BUGS:

                The #if expression processor uses signed integers  only.
                I.e, #if 0xFFFFu < 0 may be TRUE.

-h- cpp.rno	Thu Mar 14 13:50:42 1985	CPP.RNO;85
.lm 8.rm 72.nhy

.no autosubtitle .style headers 3,0,0
.pg.uc.ps 58,80.lm 8.rm 72
.hd
.hd mixed
.head mixed

.st ########cpp#####C Pre-Processor
.pg
.hl 1 ^&C Pre-Processor\&
.s 2
.c ;*******
.c ;* cpp *
.c ;*******
.s 2
.lm +8
.s.i -8;NAME:	cpp -- C Pre-Processor
.s.f
.i -8;SYNOPSIS:
.s.nf
cpp [-options] [infile [outfile]]
.s.f
.i -8;DESCRIPTION:
.s
CPP reads a C source file, expands macros and include
files, and writes an input file for the C compiler.
If no file arguments are given, CPP reads from stdin
and writes to stdout.  If one file argument is given,
it will define the input file, while two file arguments
define both input and output files.  The file name "-"
is a synonym for stdin or stdout as appropriate.
.s
The following options are supported.  Options may
be given in either case.
.lm +16
.p -16
--C		If set, source-file comments are written
to the output file.  This allows the output of CPP to be
used as the input to a program, such as lint, that expects
commands embedded in specially-formatted comments.
.p -16
--Dname=value	Define the name as if the programmer wrote
.s
.nf
    _#define name value
.s
.fill
at the start of the first file.  If "=value" is not
given, a value of "1" will be used.
.s
On non-unix systems, all alphabetic text will be forced
to upper-case.
.p -16
--E		Always return "success" to the operating
system, even if errors were detected.  Note that some fatal
errors, such as a missing _#include file, will terminate
CPP, returning "failure" even if the -E option is given.
.p -16
--Idirectory	Add this directory to the list of
directories searched for _#include "..." and _#include <...>
commands.  Note that there is no space between the
"-I" and the directory string.  More than one -I command
is permitted.  On non-Unix systems "directory" is forced
to upper-case.
.p -16
--N		CPP normally predefines some symbols defining
the target computer and operating system.  If -N is specified,
no symbols will be predefined.  If -N -N is specified, the
"always present" symbols, ____LINE____, ____FILE____, and ____DATE____
are not defined.
.p -16
--Stext		CPP normally assumes that the size of
the target computer's basic variable types is the same as the size
of these types of the host computer.  (This can be overridden
when CPP is compiled, however.)  The -S option allows dynamic
respecification of these values.  "text" is a string of
numbers, separated by commas, that specifies correct sizes.
The sizes must be specified in the exact order:
.s
.nf
    char short int long float double
.s
.fill
If you specify the option as "-S*text", pointers to these
types will be specified.  -S* takes one additional argument
for pointer to function (e.g. int (*)())
.s
For example, to specify sizes appropriate for a PDP-11,
you would write:
.s
.nf
       c s i l f d func
     -S1,2,2,2,4,8,
    -S*2,2,2,2,2,2,2
.s
.fill
Note that all values must be specified.
.p -16
--Uname		Undefine the name as if
.s
.nf
    _#undef name
.s
.fill
were given.  On non-Unix systems, "name" will be forced to
upper-case.
.p -16
--Xnumber	Enable debugging code.  If no value is
given, a value of 1 will be used.  (For maintenence of
CPP only.)
.s.lm -16
.s
.i -8;PRE-DEFINED VARIABLES:
.s
When CPP begins processing, the following variables will
have been defined (unless the -N option is specified):
.s
Target computer (as appropriate):
.s
.nf
    pdp11, vax, M68000 m68000 m68k
.fill
.s
Target operating system (as appropriate):
.s
.nf
    rsx, rt11, vms, unix
.fill
.s
Target compiler (as appropriate):
.s
.nf
    decus, vax11c
.fill
.s
The implementor may add definitions to this list.
The default definitions match the definition of the
host computer, operating system, and C compiler.
.s
The following are always available unless undefined (or
--N was specified twice):
.lm +16
.p -12
____FILE____	The input (or _#include) file being compiled
(as a quoted string).
.p -12
____LINE____	The line number being compiled.
.p -12
____DATE____	The date and time of compilation as
a Unix ctime quoted string (the trailing newline is removed).
Thus,
.s
.nf
    printf("Bug at line _%s,", ____LINE____);
    printf(" source file _%s", ____FILE____);
    printf(" compiled on _%s", ____DATE____);
.fill
.s.lm -16
.s
.i -8;DRAFT PROPOSED ANSI STANDARD CONSIDERATIONS:
.s
The current version of the Draft Proposed Standard
explicitly states that "readers are requested not to specify
or claim conformance to this draft."  Readers and users
of Decus CPP should not assume that Decus CPP conforms
to the standard, or that it will conform to the actual
C Language Standard.
.s
When CPP is itself compiled, many features of the Draft
Proposed Standard that are incompatible with existing
preprocessors may be disabled.  See the comments in CPP's
source for details.
.s
The latest version of the Draft Proposed Standard (as reflected
in Decus CPP) is dated November 12, 1984.
.s
Comments are removed from the input text.  The comment
is replaced by a single space character.  The -C option
preserves comments, writing them to the output file.
.s
The '$' character is considered to be a letter.  This is
a permitted extension.
.s
The following new features of C are processed by CPP:
.s.comment Note: significant spaces, not tabs, .br quotes #if, #elif
.br;####_#elif expression    (_#else _#if)
.br;####'_\xNNN'             (Hexadecimal constant)
.br;####'_\a'                (Ascii BELL)
.br;####'_\v'                (Ascii Vertical Tab)
.br;####_#if defined NAME    1 if defined, 0 if not
.br;####_#if defined (NAME)  1 if defined, 0 if not
.br;####_#if sizeof (basic type)
.br;####unary +
.br;####123U, 123LU          Unsigned ints and longs.
.br;####12.3L                Long double numbers
.br;####token_#token         Token concatenation
.br;####_#include token      Expands to filename
.s
The Draft Proposed Standard has extended C, adding a constant
string concatenation operator, where
.s
.nf
    "foo" "bar"
.s
.fill
is regarded as the single string "foobar".  (This does not
affect CPP's processing but does permit a limited form of
macro argument substitution into strings as will be discussed.)
.s
The Standard Committee plans to add token concatenation
to _#define command lines.  One suggested implementation
is as follows:  the sequence "Token1_#Token2" is treated
as if the programmer wrote "Token1Token2".  This could
be used as follows:
.s
.nf
    _#line 123
    _#define ATLINE foo_#____LINE____
.s
.fill
ATLINE would be defined as foo123.
.s
Note that "Token2" must either have the format of an
identifier or be a string of digits.  Thus, the string
.s
.nf
    _#define ATLINE foo_#1x3
.s
.fill
generates two tokens: "foo1" and "x3".
.s
If the tokens T1 and T2 are concatenated into T3,
this implementation operates as follows:
.s
.nf
  1. Expand T1 if it is a macro.
  2. Expand T2 if it is a macro.
  3. Join the tokens, forming T3.
  4. Expand T3 if it is a macro.
.s
.fill
A macro formal parameter will be substituted into a string
or character constant if it is the only component of that
constant:
.s
.nf
    _#define VECSIZE 123
    _#define vprint(name, size) _\
      printf("name" "[" "size" "] = {_\n")
      ... vprint(vector, VECSIZE);
.s
.fill
expands (effectively) to
.s
.nf
      vprint("vector[123] = {_\n");
.s
.fill
Note that this will be useful if your C compiler supports
the new string concatenation operation noted above.
As implemented here, if you write
.s
.nf
    _#define string(arg) "arg"
      ... string("foo") ...
.s
.fill
This implementation generates "foo", rather than the strictly
correct ""foo"" (which will probably generate an error message).
This is, strictly speaking, an error in CPP and may be removed
from future releases.
.s
.i -8;ERROR MESSAGES:
.s
Many.  CPP prints warning or error messages if you try to
use multiple-byte character constants (non-transportable)
if you _#undef a symbol that was not defined, or if your
program has potentially nested comments.
.s
.i -8;AUTHOR:
.s
Martin Minow
.s
.i -8;BUGS:
.s
The _#if expression processor uses signed integers only.
I.e, _#if 0xFFFFu < 0 may be TRUE.
.s
.lm 8.rm 72.nhy

-h- cpp.1	Thu Mar 14 13:50:42 1985	CPP.1;1
.TH CPP 1
.SH NAME
cpp \- C Pre-Processor
.SH SYNOPSIS
.B cpp
[-options] [infile [outfile]]
.SH DESCRIPTION
.I Cpp
reads a C source file, expands macros and include
files, and writes an input file for the C compiler.
If no file arguments are given,
.I cpp
reads from stdin and
writes to stdout.
If one file argument is given, it
will define the input file,
while two file arguments
define both input and output files.
.PP
The following options are supported.
Options may be given in either case.
.TP 10
.BI \-I directory
Add this directory to the list of directories searched for
#include "..."
and
#include <...> commands.
Note that there is no space between the
.B \-I
and the directory string.
More than one
.B \-I
command is permitted.
On non-Unix systems
.I directory
is forced to upper-case.
.TP 10
.BI \-D name=value
Define the name as if the programmer wrote

		#define name value

at the start of the first file.
If
.I =value
is not given,
a value of "1"
will be used.

On non-unix systems,
all alphabetic text
will be forced to upper-case.
.TP 10
.BI \-U name
Undefine the name as if

		#undef name

were given.
On non-Unix systems,
.I name
will be forced to upper-case.

The following variables are pre-defined:

Target computer (as appropriate):

	pdp11, vax, M68000 m68000 m68k

Target operating system (as appropriate):

	rsx, rt11, vms, unix

Target compiler (as appropriate):

	decus, vax11c

The implementor may add definitions to this list.
The default definitions match the definition of the host
computer, operating system, and C compiler.

The following are always available unless undefined:
.RS
.TP 10
__FILE__
The input (or #include) file being compiled (as a quoted string).
.TP 10
__LINE__
The line number being compiled.
.TP 10
__DATE__
The date and time of compilation as a Unix ctime quoted string
(the trailing newline is removed).
Thus,

   printf("Bug at line %s,", __LINE__);
   printf(" source file %s", __FILE__);
   printf(" compiled on %s", __DATE__);
.RE
.TP 10
.BI \-X number
Enable debugging code.
If no value is given,
a value of 1 will be used.
(For maintenence of CPP only.)
.SH DRAFT ANSI STANDARD CONSIDERATIONS:
.LP
Comments are removed from the input text.
The comment is replaced by a single space character.
This differs from usage on some existing preprocessors
(but it follows the Draft Ansi C Standard).
.LP
Note that arguments may be concatenated as follows:

    #define I(x)x
    #define CAT(x,y)I(x)y
    int value = CAT(1,2);
.LP
If the above macros are defined and invoked without
extraneous spaces,
they will be transportable to other
implementations.
Unfortunately,
this will not properly expand

    int CAT(foo,__LINE__);
    int CAT(foo,__LINE__);
.LP
as __LINE__ is copied into the input stream,
yielding
"foo__LINE__"
in both cases,
rather than the expected
"foo123", "foo124",
which would result if
__LINE__
were expanded and the result copied into the input stream.
.LP
Macro formal parameters are not recognized within quoted
strings and character constants in macro definitions.
.LP
CPP implements most of the ANSI draft standard.
You should be aware of the following differences:
.TP 4
o
In the draft standard,
the \\n (backslash-newline)
character is "invisible" to all processing.
In this implementation,
it is invisible to strings,
but acts as a "whitespace" (token-delimiter) outside of strings.
This considerably simplifies error message handling.
.TP 4
o
The following new features of C are processed by cpp:

    #elif expression     (#else #if)
    '\\xNNN'              (Hexadecimal constants)
    \'\\a'                 (Ascii BELL [silly])
    \'\\v'                 (Ascii VT)
    #if defined NAME     (1 if defined, 0 if not)
    #if defined (NAME)   (1 if defined, 0 if not)
    unary +              (gag me with a spoon)
.TP 4
o
The draft standard has extended C,
adding a string concatenation operator,
where

	"foo" "bar"

is regarded as the single string "foobar".
(This does not affect CPP's processing.)
.SH ERROR MESSAGES:
Many.
CPP
prints warning messages if you try to use
multiple-byte character constants (non-transportable) or
if you #undef a symbol that was not defined.
.SH BUGS:
Cpp prints spurious error or warning messages in #if
sequences such as the following:

    #define foo 0
    #if (foo != 0) ? (100 / foo) : 0
    #undef foo
    #if ((defined(foo)) ? foo : 0) == 1

Cpp
should supress the error message if the expression's
value is already known.
.SH AUTHOR:
Martin Minow
-h- makefile.txt	Thu Mar 14 13:50:42 1985	MAKEFILE.TXT;33
# Unix makefile for cpp
#
# The redefinition of strchr() and strrchr() are needed for
# Ultrix-32, Unix 4.2 bsd (and maybe some other Unices).
#
BSDDEFINE = -Dstrchr=index -Dstrrchr=rindex
#
# On certain systems, such as Unix System III, you may need to define
# $(LINTFLAGS) in the make command line to set system-specific lint flags.
#
# This Makefile assumes cpp will replace the "standard" preprocessor.
# Delete the reference to -DLINE_PREFIX=\"\" if cpp is used stand-alone.
# LINEFIX is a sed script filter that reinserts #line -- used for testing
# if LINE_PREFIX is set to "".   Note that we must stand on our heads to
# match the # and a line had better not begin with $.  By the way, what
# we really want is
#	LINEFIX = | sed "s/^#/#line/"
#
CPPDEFINE = -DLINE_PREFIX=\"\"
LINEFIX = | sed "s/^[^ !\"%-~]/&line/"
#
# Define OLD_PREPROCESSOR non-zero to make a preprocessor which is
# "as compatible as possible" with the standard Unix V7 or Ultrix
# preprocessors.  This is needed to rebuild 4.2bsd, for example, as
# the preprocessor is used to modify assembler code, rather than C.
# This is not recommended for current development.  OLD_PREPROCESSOR
# forces the following definitions:
#   OK_DOLLAR		FALSE	$ is not allowed in variables
#   OK_CONCAT		FALSE	# cannot concatenate tokens
#   COMMENT_INVISIBLE	TRUE	old-style comment concatenation
#   STRING_FORMAL	TRUE	old-style string expansion
#
OLDDEFINE = -DOLD_PREPROCESSOR=1
#
# DEFINES collects all -D arguments for cc and lint:
# Change DEFINES = $(BSDDEFINE) $(CPPDEFINE) $(OLDDEFINE)
# for an old-style preprocessor.
#
DEFINES = $(BSDDEFINE) $(CPPDEFINE)

CFLAGS = -O $(DEFINES)

#
# ** compile cpp
#
SRCS = cpp1.c cpp2.c cpp3.c cpp4.c cpp5.c cpp6.c
OBJS = cpp1.o cpp2.o cpp3.o cpp4.o cpp5.o cpp6.o
cpp: $(OBJS)
	$(CC) $(CFLAGS) $(OBJS) -o cpp

#
# ** manual page
#
man:	cpp.1
	nroff -man cpp.1 >cpp.man

#
# ** Test cpp by preprocessing itself, compiling the result,
# ** repeating the process and diff'ing the result.  Note: this
# ** is not a good test of cpp, but a simple verification.
# ** The diff's should not report any changes.
# ** Note that a sed script may be executed for each compile
#
test:
	cpp cpp1.c $(LINEFIX) >old.tmp1.c
	cpp cpp2.c $(LINEFIX) >old.tmp2.c
	cpp cpp3.c $(LINEFIX) >old.tmp3.c
	cpp cpp4.c $(LINEFIX) >old.tmp4.c
	cpp cpp5.c $(LINEFIX) >old.tmp5.c
	cpp cpp6.c $(LINEFIX) >old.tmp6.c
	$(CC) $(CFLAGS) old.tmp[123456].c
	a.out cpp1.c >new.tmp1.c
	a.out cpp2.c >new.tmp2.c
	a.out cpp3.c >new.tmp3.c
	a.out cpp4.c >new.tmp4.c
	a.out cpp5.c >new.tmp5.c
	a.out cpp6.c >new.tmp6.c
	diff old.tmp1.c new.tmp1.c
	diff old.tmp2.c new.tmp2.c
	diff old.tmp3.c new.tmp3.c
	diff old.tmp4.c new.tmp4.c
	diff old.tmp5.c new.tmp5.c
	diff old.tmp6.c new.tmp6.c
	rm a.out old.tmp[123456].* new.tmp[123456].*

#
# A somewhat more extensive test is provided by the "clock"
# program (which is not distributed).  Substitute your favorite
# macro-rich program here.
#
clock:	clock.c cpp
	cpp clock.c $(LINEFIX) >temp.cpp.c
	cc temp.cpp.c -lcurses -ltermcap -o clock
	rm temp.cpp.c

#
# ** Lint the code
#

lint:	$(SRCS)
	lint $(LINTFLAGS) $(DEFINES) $(SRCS)

#
# ** Remove unneeded files
#
clean:
	rm -f $(OBJS) cpp

#
# ** Rebuild the archive files needed to distribute cpp
# ** Uses the Decus C archive utility.
#

archc:	archc.c
	$(CC) $(CFLAGS) archc.c -o archc

archx:	archx.c
	$(CC) $(CFLAGS) archx.c -o archx

archive: archc
	archc readme.txt cpp.mem archx.c archc.c cpp.rno cpp.1 \
		makefile.txt cpp*.h >cpp1.arc
	archc cpp1.c cpp2.c cpp3.c >cpp2.arc
	archc cpp4.c cpp5.c cpp6.c >cpp3.arc

#
# Object module dependencies
#

cpp1.o	:	cpp1.c cpp.h cppdef.h

cpp2.o	:	cpp2.c cpp.h cppdef.h

cpp3.o	:	cpp3.c cpp.h cppdef.h

cpp4.o	:	cpp4.c cpp.h cppdef.h

cpp5.o	:	cpp5.c cpp.h cppdef.h

cpp6.o	:	cpp6.c cpp.h cppdef.h

cpp.man	:	cpp.1


-h- cpp.h	Thu Mar 14 13:50:42 1985	CPP.H;120

/*
 *	I n t e r n a l   D e f i n i t i o n s    f o r   C P P
 *
 * In general, definitions in this file should not be changed.
 */

#ifndef	TRUE
#define	TRUE		1
#define	FALSE		0
#endif
#ifndef	EOS
/*
 * This is predefined in Decus C
 */
#define	EOS		'\0'		/* End of string		*/
#endif
#define	EOF_CHAR	0		/* Returned by get() on eof	*/
#define NULLST		((char *) NULL)	/* Pointer to nowhere (linted)	*/
#define	DEF_NOARGS	(-1)		/* #define foo vs #define foo()	*/

/*
 * The following may need to change if the host system doesn't use ASCII.
 */
#define	DEF_MAGIC	0x1D		/* Magic for #defines		*/
#define	TOK_SEP		0x1E		/* Token concatenation delim.	*/
#define COM_SEP		0x1F		/* Magic comment separator	*/

/*
 * Note -- in Ascii, the following will map macro formals onto DEL + the
 * C1 control character region (decimal 128 .. (128 + PAR_MAC)) which will
 * be ok as long as PAR_MAC is less than 33).  Note that the last PAR_MAC
 * value is reserved for string substitution.
 */

#define	MAC_PARM	0x7F		/* Macro formals start here	*/
#if PAR_MAC >= 33
	assertion fails -- PAR_MAC isn't less than 33
#endif
#define	LASTPARM	(PAR_MAC - 1)

/*
 * Character type codes.
 */

#define	INV		0		/* Invalid, must be zero	*/
#define	OP_EOE		INV		/* End of expression		*/
#define	DIG		1		/* Digit			*/
#define	LET		2		/* Identifier start		*/
#define	FIRST_BINOP	OP_ADD
#define	OP_ADD		3
#define	OP_SUB		4
#define	OP_MUL		5
#define	OP_DIV		6
#define	OP_MOD		7
#define	OP_ASL		8
#define	OP_ASR		9
#define	OP_AND		10		/* &, not &&			*/
#define	OP_OR		11		/* |, not ||			*/
#define	OP_XOR		12
#define	OP_EQ		13
#define	OP_NE		14
#define	OP_LT		15
#define	OP_LE		16
#define	OP_GE		17
#define	OP_GT		18
#define	OP_ANA		19		/* &&				*/
#define	OP_ORO		20		/* ||				*/
#define	OP_QUE		21		/* ?				*/
#define	OP_COL		22		/* :				*/
#define	OP_CMA		23		/* , (relevant?)		*/
#define	LAST_BINOP	OP_CMA		/* Last binary operand		*/
/*
 * The following are unary.
 */
#define	FIRST_UNOP	OP_PLU		/* First Unary operand		*/
#define	OP_PLU		24		/* + (draft ANSI standard)	*/
#define	OP_NEG		25		/* -				*/
#define	OP_COM		26		/* ~				*/
#define	OP_NOT		27		/* !				*/
#define	LAST_UNOP	OP_NOT
#define	OP_LPA		28		/* (				*/
#define	OP_RPA		29		/* )				*/
#define	OP_END		30		/* End of expression marker	*/
#define	OP_MAX		(OP_END + 1)	/* Number of operators		*/
#define	OP_FAIL		(OP_END + 1)	/* For error returns		*/

/*
 * The following are for lexical scanning only.
 */

#define	QUO		65		/* Both flavors of quotation	*/
#define	DOT		66		/* . might start a number	*/
#define	SPA		67		/* Space and tab		*/
#define	BSH		68		/* Just a backslash		*/
#define	END		69		/* EOF				*/

/*
 * These bits are set in ifstack[]
 */
#define	WAS_COMPILING	1		/* TRUE if compile set at entry	*/
#define	ELSE_SEEN	2		/* TRUE when #else processed	*/
#define	TRUE_SEEN	4		/* TRUE when #if TRUE processed	*/

/*
 * Define bits for the basic types and their adjectives
 */

#define	T_CHAR		  1
#define	T_INT		  2
#define	T_FLOAT		  4
#define	T_DOUBLE	  8
#define	T_SHORT		 16
#define	T_LONG		 32
#define	T_SIGNED	 64
#define	T_UNSIGNED	128
#define	T_PTR		256		/* Pointer			*/
#define	T_FPTR		512		/* Pointer to functions		*/
